# 코드 처리하기
### Category: 조건문

### 😀️문제설명

문자열 code가 주어집니다.
code를 앞에서부터 읽으면서 만약 문자가 "1"이면 mode를 바꿉니다. mode에 따라 code를 읽어가면서 문자열 ret을 만들어냅니다.

mode는 0과 1이 있으며, idx를 0 부터 code의 길이 - 1 까지 1씩 키워나가면서 code[idx]의 값에 따라 다음과 같이 행동합니다.

mode가 0일 때
code[idx]가 "1"이 아니면 idx가 짝수일 때만 ret의 맨 뒤에 code[idx]를 추가합니다.
code[idx]가 "1"이면 mode를 0에서 1로 바꿉니다.
mode가 1일 때
code[idx]가 "1"이 아니면 idx가 홀수일 때만 ret의 맨 뒤에 code[idx]를 추가합니다.
code[idx]가 "1"이면 mode를 1에서 0으로 바꿉니다.
문자열 code를 통해 만들어진 문자열 ret를 return 하는 solution 함수를 완성해 주세요.

단, 시작할 때 mode는 0이며, return 하려는 ret가 만약 빈 문자열이라면 대신 "EMPTY"를 return 합니다.

### 😍기초 다지기
1. 자바에서는 지역변수에 대한 초기화 없이 변수에 접근하는 것을 허용하지 않는다.
2. 자바에서 ''와 ""는 다르다.
- "": String. 0 개의 문자를 포함하는 유효한 문자열이다.
- '': char은 반드시 단일 문자를 포함해야 한다. 빈 문자는 유효하지 않으므로 컴파일 오류가 발생한다.
3. 삼항 연산자의 결과는 반드시 값이어야 하고 두번째, 세번째 피 연산자의 결과 타입이 같아야 한다.
* EX) code.charAt(i) == 1 ? (mode = 1) : ((i % 2 == 0) && (sb.append(code.charAt(i))));
* 대입 연산자는 변수에 대입한 값을 리턴한다. 
  * 따라서 mode = 1은 1을 반환한다.
- 자바에서 논리 연산자는 반드시 불리언 값을 반환한다.
  - EX) (i % 2 == 0) && (ret.append(code.charAt(i));
    - ret.append는 리턴값이 없는 메서드 타입이다. 따라서 논리적인 값으로 평가되지 않는다.
4. c == 1과 c == '1'은 다르다.
- char는 유니코드 값을 저장하는 정수형 데이터 타입이다.
  - '1'는 유니코드 테이블에서 아스키 값 49에 해당한다.
  - 1은 32비트 정수형 데이터 타입으로 숫자 1을 나타낸다.
  - 자바에서는 서로 다른 타입을 비교할 때 형 변환이 발생하는데 char와 int를 비교하면 char가 자동으로 int 타입으로 변환한다. 즉, '1' == 1을 실행하면 '1'은 유니코드 값 49로 변환되어 49 == 1이 실행된다.
5. String은 char의 부모 타입이 아니다. 
- char는 Integer가 부모 타입이다. 따라서 형변환할 수 없다. 
- char -> String을 하려면 String.valueOf를 사용해야한다.

### 👍UPGRADE 포인트
1. mode가 기준이 아닌 code[idx]값을 기준으로 하면 어차피 mode가 0이든 1이든 code[idx] 값이 1이면 할 수 있는 일은 mode를 바꾸는 작업밖에 없으므로
code[idx]를 우선적으로 기준으로 잡아 처리하고 다음으로 넘기면 된다.
2. mode는 0과 1중에 하나이고 mode가 0일때 i % 2가 0이면 그때의 code[idx]값을 추가하고 mode가 1일 때 i % 2가 1이면 그때의 code[idex]값을 추가하므로
아래와 같이 한번에 i % 2값이 mode값일 때로 간추릴 수 있다